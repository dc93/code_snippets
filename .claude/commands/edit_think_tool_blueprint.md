## Using think tool

## IN-DEPTH PROBLEM ANALYSIS
- Describe in detail the fundamental problem you intend to solve
- Analyze previous solution attempts and their limitations
- Identify the root causes of the problem, not just the surface symptoms
- Quantify the problem's impact (data, metrics, costs, inefficiencies)
- Consider hidden dimensions of the problem (psychological, social, ethical)

## PROJECT VISION
- Project name and conceptual identity
- Articulate an ambitious yet achievable vision
- Define the paradigm shift that the project introduces
- Outline the expected transformative impact (short, medium, and long term)
- Identify the unique and differentiating value compared to existing solutions

## ARCHITECTURE AND PARADIGMS
- Most suitable programming paradigms (functional, OOP, reactive, etc.)
- System architecture (microservices, hexagonal, event-driven, etc.)
- Fundamental architectural patterns with justification for their selection
- Scalability model (vertical, horizontal, distributed)
- Resilience strategies and fault tolerance
- Core design principles (SOLID, DRY, KISS, with customizations)

## OPTIMAL TECHNOLOGY STACK
- Programming languages with justification for choices
- Core frameworks and libraries with pros/cons analysis
- Alternative technologies considered and reasons for their exclusion
- Integration between different technologies (interfaces, adapters, bridges)
- Testing and quality stack (unit, integration, E2E, performance, security)
- Development and deployment toolchain (build, CI/CD, containerization)

## DATA MODEL AND DOMAIN
- In-depth domain analysis (DDD)
- Core entities and value objects with invariants and business rules
- Complex relationships and integrity constraints
- Persistence strategy (SQL, NoSQL, hybrid, event sourcing)
- Data model evolution over time (migrations, versioning)
- Query optimization and data access

## CORE FUNCTIONALITY WITH REASONING
For each fundamental feature:
- Specific problem it solves in the general context
- Expected behavior with complete use cases (happy path and edge cases)
- Optimal algorithms and data structures with complexity analysis
- Trade-offs considered (performance vs. readability, flexibility vs. simplicity)
- Interactions with other system components
- Comprehensive testing (unit, integration, property-based, fuzzing)

## INNOVATION AND DIFFERENTIATION
- Innovative elements of the project (technological, methodological, conceptual)
- Use of advanced techniques (ML/AI, specialized algorithms, optimizations)
- Unconventional approaches that overcome limitations of existing solutions
- Potential for patents or intellectual property
- Technological evolution roadmap

## HUMAN-COMPUTER INTERACTION
- User mental model and detailed journey map
- Applied UX/UI principles with psychological/cognitive justification
- Universal accessibility (WCAG 2.2 AAA or higher)
- Advanced internationalization and localization
- Feedback loops and continuous improvement based on data
- Alternative interfaces (voice, gesture, AR/VR if applicable)

## SECURITY AND PRIVACY BY DESIGN
- Comprehensive threat model (STRIDE, PASTA)
- Mitigation strategies for each threat category
- Privacy by design (data minimization, pseudonymization, etc.)
- Regulatory compliance (GDPR, CCPA, HIPAA, etc. if applicable)
- Sensitive data lifecycle management
- Forensic audit and logging

## SCALABILITY AND PERFORMANCE
- Analysis of potential bottlenecks
- Multi-level caching strategies
- Parallelization and concurrency
- Algorithmic optimization and data access patterns
- Sharding and partitioning strategies
- Key performance metrics and related SLAs/SLOs

## SUSTAINABILITY AND ETHICS
- Software ecological footprint and reduction strategies
- Economic accessibility and social inclusivity
- Ethical considerations on data usage and algorithms
- Potential negative social impacts and their mitigation
- Contribution to UN Sustainable Development Goals

## COMPLEXITY MANAGEMENT
- System decomposition into manageable modules
- Clean interfaces between components
- Change isolation strategies
- Progressive and multi-level documentation
- Onboarding for new developers

## IMPLEMENTATION AND QUALITY
- Incremental implementation strategies
- End-to-end quality assurance pipeline
- Test automation (unit, integration, E2E, performance, security)
- Code review and quality standards
- Continuous monitoring and alerting
- Zero-downtime deployment and canary/blue-green

## SUCCESS METRICS
- Technical and business KPIs
- Impact measurement framework
- Feedback and iteration cycles
- User adoption and satisfaction metrics
- ROI and value creation

## EVOLUTION PLAN
- Short, medium, and long-term roadmap
- Technical and business milestones
- Technical debt management
- Sunset strategies for legacy components
- Preparation for future technological paradigms

---

## PRACTICAL EXECUTION
- Structured repository with folder architecture
- Coding conventions and style
- API documentation (OpenAPI/Swagger, GraphQL Schema)
- Development environment setup (from zero to productive in minutes)
- Contribution processes (git flow, PR template, etc.)